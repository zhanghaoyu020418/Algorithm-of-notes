# 贪心算法

### 股票买卖2
给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;
int a[N];

int main ()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; i ++)
        scanf("%d", &a[i]);
    int res = 0;
    for (int i = 1; i < n; i ++)
        if(a[i] > a[i - 1])//如果后面一个值比前面一个值大，就交易一次
            res += a[i] - a[i - 1];
    cout << res << endl;
    return 0;
}
```

### 仓货选址
在一条数轴上有 N 家商店，它们的坐标分别为 A1~AN。

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;
int a[N];
int sum;

int main ()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; i ++)
        cin >> a[i];
    
    sort(a, a + n);
    
    int res = 0;
    for (int i = 0; i < n; i ++)
        res += abs(a[i] - a[n / 2]);
    
    cout << res << endl;
    
    return 0;
}
```

### 糖果传递

有n个小朋友坐成一圈，每人有a[i]个糖果。

每人只能给左右两人传递糖果。

每人每次传递一个糖果代价为1。

求使所有人获得均等糖果的最小代价。

```cpp
#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

typedef long long LL;
const int N = 1000010;
LL a[N];
LL c[N];
LL sum;

int main ()
{
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i ++)
    {
        cin >> a[i];
        sum += a[i];
    }
    LL avg = sum / n;//算平均糖果数量
    
    //公式
    for (int i = n - 1; i >= 0; i --)
    {
        c[i] = c[i + 1] + avg - a[i];
    }
    //c[1] = 0;
    
    //排序找中位数,(中位数就是距离之和最小的位置)
    sort(c , c + n);
    LL res = 0;
    for (int i = 0; i < n; i ++)
    {
        res += abs(c[i] - c[n >> 1]);
    }
    cout << res << endl;
    return 0;
}
```

### 雷达设备
假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。

每个小岛都位于海洋一侧的某个点上。

雷达装置均位于海岸线上，且雷达的监测范围为d，当小岛与某雷达的距离不超过d时，该小岛可以被雷达覆盖。

我们使用笛卡尔坐标系，定义海岸线为x轴，海的一侧在x轴上方，陆地一侧在x轴下方。

现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。

**总结：**
==在若干区间内，最少选多少个点，可以使得每个区间都有点==

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 1010;
int x, y;
int n, d;

struct Segment
{
    double l;
    double r;
}Seg[N];

int cmp(Segment a, Segment b)
{
    return b.r > a.r;
}

int main ()
{
    cin >> n >> d;
    for (int i = 0; i < n; i ++)
    {
        cin >> x >> y;
        if(y > d)
        {
            cout << "-1" << endl;  
            return 0;
        }
        //圆的坐标不好处理，所以将点放到坐标轴上最小的距离
        double len = sqrt(d * d - y * y);
        Seg[i].l = x - len;
        Seg[i].r = x + len;

    }
    
    sort(Seg, Seg + n, cmp);//按右端点排序

    int res = 0;
    double point = -1e10;
    for (int i = 0; i < n; i ++)
    {
        if(Seg[i].l > point)
        {
            point = Seg[i].r;
            res++;
        }
    }

    cout << res << endl;
    return 0;
}
```